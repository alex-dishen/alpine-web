# Alpine Web Architecture

## Folder Structure

```
alpine-web/
├── .husky/              # Git hooks
├── docs/                # Documentation
├── src/
│   ├── app/             # Application shell
│   │   ├── providers/   # React context providers
│   │   └── routes/      # TanStack Router file-based routes
│   ├── pages/           # Page components (one per route)
│   │   └── [page-name]/
│   │       ├── features/    # Page-specific UI components
│   │       ├── registry/    # Constants and types
│   │       ├── model/       # Hooks with business logic
│   │       └── [page].page.tsx
│   ├── features/        # Shared feature modules
│   │   └── [feature-name]/
│   │       ├── ui/          # Feature UI components
│   │       ├── registry/    # Constants and types
│   │       ├── model/       # Hooks with business logic
│   │       └── [feature].tsx
│   ├── shared/          # Shared utilities
│   │   ├── shadcn/      # shadcn/ui components and utilities
│   │   │   ├── components/
│   │   │   ├── hooks/
│   │   │   └── utils/
│   │   ├── assets/      # SVG icons, images
│   │   └── enums/       # Shared enums
│   ├── configs/         # Application-level configurations
│   │   ├── api/         # API client and generated types
│   │   ├── auth/        # Session management
│   │   ├── query-client/# TanStack Query client
│   │   └── zustand/     # Zustand stores
│   │       ├── auth/    # Auth store
│   │       └── theme/   # Theme store
│   └── test/            # Test utilities and setup
```

## Folder Responsibilities

### `pages/` - Route Pages

Each page follows a consistent structure with internal organization:

```
pages/
└── [page-name]/
    ├── features/           # Page-specific UI components
    │   ├── [page].header.tsx
    │   ├── [page].form.tsx
    │   └── [page].list.tsx
    ├── registry/           # Constants, types, static data
    │   ├── [page].constants.ts
    │   └── [page].types.ts
    ├── model/              # Hooks with business logic
    │   └── use-[action].ts
    └── [page].page.tsx     # Main page component (composition only)
```

**Example - Login page:**

```
pages/auth/login/
├── features/
│   ├── login.header.tsx
│   ├── login.form.tsx
│   └── login.footer.tsx
├── registry/
│   └── login.types.ts      # Zod schemas, form types
├── model/
│   └── use-login.ts        # Login form logic, API mutation
└── login.page.tsx          # Composes header + form + footer
```

**Key principle:** The main page component should be pure composition with no business logic. All logic lives in `model/` hooks, used directly by the components that need them.

### `features/` - Shared Feature Modules

Features are reusable across multiple pages. They follow the same structure as pages:

```
features/
└── sidebar/
    ├── ui/                 # UI components
    │   ├── sidebar-logo.tsx
    │   ├── sidebar-nav.tsx
    │   ├── sidebar-logout-button.tsx
    │   └── sidebar-theme-toggle.tsx
    ├── registry/           # Constants and types
    │   ├── sidebar.constants.ts
    │   └── sidebar.types.ts
    ├── model/              # Business logic hooks
    │   └── use-logout.ts
    └── sidebar.tsx         # Main feature component
```

**Key principle:** Each UI component manages its own state. No props drilling from parent - components get state directly from stores or hooks.

### `configs/` - Application Infrastructure

Contains application-level singletons and configurations:

```
configs/
├── api/
│   ├── client.ts           # OpenAPI fetch client with auth middleware
│   ├── query-keys.ts       # Centralized TanStack Query keys
│   └── types/
│       └── api.generated.ts
├── auth/
│   └── session.ts          # Session restoration logic
├── query-client/
│   └── query-client.ts     # TanStack Query client instance
└── zustand/
    ├── auth/
    │   └── auth.store.ts   # Authentication state
    ├── theme/
    │   └── theme.store.ts  # Theme state with persistence
    └── modals/
        ├── modals.props.ts     # Modal props (single source of truth)
        ├── modals.registry.ts  # MODALS const, component registry
        └── modals.store.ts     # openModal, closeModal
```

### `shared/` - Pure Utilities

Contains utilities with no side effects:

```
shared/
├── shadcn/                 # shadcn/ui (auto-generated, don't edit)
│   ├── components/         # UI primitives
│   ├── hooks/              # shadcn hooks (use-mobile, etc.)
│   └── utils/              # cn() utility
├── assets/
│   └── svg/                # SVG icon components
└── enums/                  # Shared enums
```

**Note:** The `shadcn/` folder is auto-generated by the shadcn CLI. Don't manually edit files inside it.

## Architecture Patterns

### Component State Management

Components get their state directly from the source, not via props:

```typescript
// Good - component gets state directly
export const SidebarThemeToggle = () => {
  const theme = useThemeStore((state) => state.theme);
  const setTheme = useThemeStore((state) => state.setTheme);
  // ...
};

// Bad - props drilling
export const SidebarThemeToggle = ({ theme, onThemeChange }) => {
  // ...
};
```

### Page Composition Pattern

Pages are pure composition of feature components:

```typescript
// Good - pure composition
export const LoginPage = () => {
  return (
    <Card>
      <LoginHeader />
      <LoginForm />
      <LoginFooter />
    </Card>
  );
};

// Bad - logic in page
export const LoginPage = () => {
  const { data, handleSubmit } = useLogin(); // Don't do this
  return (
    <Card>
      <LoginHeader />
      <LoginForm data={data} onSubmit={handleSubmit} /> // Props drilling
    </Card>
  );
};
```

### State Management

- **Server State**: TanStack Query for data fetching and caching
- **Client State**: Zustand stores in `configs/zustand/`
- **Modals**: Centralized modal system in `configs/zustand/modals/`
- **Toasts**: sonner (global error handling via QueryClient, top-center position)
- **Local State**: React useState for component-level state

### Modals

Modals use a centralized Zustand-based system. Props are defined in `modals.props.ts`, registered in `modals.registry.ts`, and opened via the store:

```typescript
import { useModalsStore } from '@/configs/zustand/modals/modals.store';
import { MODALS } from '@/configs/zustand/modals/modals.registry';

const openModal = useModalsStore((state) => state.openModal);
openModal(MODALS.JobsDetail, { jobId: '123' });
```

Use the `/modals` skill when creating new modals.

### API Integration

OpenAPI stack for type-safe API calls:

1. `openapi-typescript` generates types from OpenAPI spec
2. `openapi-fetch` provides a type-safe fetch client
3. `openapi-react-query` creates TanStack Query hooks

```typescript
// configs/api/client.ts
export const $api = createClient(fetchClient);
export const $publicApi = createClient(publicFetchClient);

// configs/api/query-keys.ts - centralized query keys
export const JOBS_QUERY_KEY = ['jobs'] as const;
export const STAGES_QUERY_KEY = ['get', '/api/jobs/stages'] as const;

// Usage in hooks - always use $api.useMutation, not raw useMutation
// Always import query keys from @/configs/api/query-keys
import { JOBS_QUERY_KEY } from '@/configs/api/query-keys';

const mutation = $api.useMutation('post', '/api/jobs', {
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: JOBS_QUERY_KEY });
  },
});

// At call site - generate ID where data is formed
mutation.mutate({
  body: {
    id: crypto.randomUUID(),
    ...formData,
  },
});
```

**Query keys**: All query keys are centralized in `@/configs/api/query-keys.ts`. Never use inline query keys like `['jobs']` directly—always import from this file.

**Error handling**: Errors are handled globally via `QueryCache` and `MutationCache` in `query-client.ts`. Errors automatically display via sonner toasts. Don't add `onError` handlers for toast notifications.

**ID generation**: Generate IDs at the call site (where data is formed), not inside mutation hooks.

### Routing

TanStack Router with file-based routing:

- Routes defined in `src/app/routes/`
- Protected routes under `_authenticated/` layout
- Auth routes under `auth/`

```
routes/
├── __root.tsx              # Root layout
├── _authenticated.tsx      # Protected layout (checks auth)
├── _authenticated/
│   ├── index.tsx           # Home (protected)
│   ├── jobs.tsx
│   └── ...
└── auth/
    ├── login.tsx
    ├── signup.tsx
    └── callback.tsx
```

## Advanced Patterns

### Dynamic Column Generation

For tables with user-configurable columns, use a factory function pattern:

```typescript
// jobs-table-columns.tsx
type CreateJobColumnsOptions = {
  columns: Column[];           // Dynamic columns from API
  stages: Stage[];             // Reference data
  onUpdateJob: (id: string, field: string, value: unknown) => void;
  onUpdateColumnValue: (jobId: string, columnId: string, value: Record<string, unknown>) => void;
  onDeleteJob: (id: string) => void;
  onOpenDetail: (id: string) => void;
};

export const createJobColumns = (options: CreateJobColumnsOptions): ColumnDef<Job>[] => {
  const { columns, stages, onUpdateJob, onUpdateColumnValue, onDeleteJob, onOpenDetail } = options;

  // System columns (always present)
  const systemColumns: ColumnDef<Job>[] = [
    {
      id: 'company_name',
      header: 'Company',
      cell: ({ row }) => (
        <TextCell
          value={row.original.company_name}
          onChange={(value) => onUpdateJob(row.original.id, 'company_name', value)}
        />
      ),
    },
    // ... other system columns
  ];

  // Dynamic columns (from API)
  const dynamicColumns: ColumnDef<Job>[] = columns.map((column) => ({
    id: column.id,
    header: column.name,
    cell: ({ row }) => (
      <DynamicCell
        column={column}
        value={row.original.column_values?.[column.id]}
        onChange={(value) => onUpdateColumnValue(row.original.id, column.id, value)}
      />
    ),
  }));

  return [...systemColumns, ...dynamicColumns];
};
```

**Usage in hook:**

```typescript
const tableColumns = useMemo(
  () =>
    createJobColumns({
      columns,
      stages,
      onUpdateJob,
      onDeleteJob,
      onOpenDetail,
    }),
  [columns, stages, onUpdateJob, onDeleteJob, onOpenDetail]
);
```

### Inline Cell Editing

Self-contained editable cells manage their own edit state:

```typescript
type TextCellProps = {
  value: string;
  onChange: (value: string) => void;
};

export const TextCell = ({ value, onChange }: TextCellProps) => {
  const [isEditing, setIsEditing] = useState(false);
  const [editValue, setEditValue] = useState(value);

  // Sync with external value changes
  useEffect(() => {
    setEditValue(value);
  }, [value]);

  const handleBlur = () => {
    setIsEditing(false);
    // Only trigger onChange if value actually changed
    if (editValue !== value) {
      onChange(editValue);
    }
  };

  if (isEditing) {
    return (
      <Input
        value={editValue}
        onChange={(e) => setEditValue(e.target.value)}
        onBlur={handleBlur}
        onKeyDown={(e) => e.key === 'Enter' && handleBlur()}
        autoFocus
      />
    );
  }

  return (
    <div onClick={() => setIsEditing(true)} className="cursor-pointer">
      {value || <span className="text-muted-foreground">-</span>}
    </div>
  );
};
```

**Key points:**

- Cell manages its own `isEditing` state
- Only calls `onChange` when value actually changes (avoids unnecessary mutations)
- Syncs with external value via `useEffect` for optimistic updates

## Import Conventions

### Absolute Imports Only

Use the `@/` alias for all imports. No relative imports (except in `shared/shadcn/`):

```typescript
// Good - absolute imports
import { Button } from '@/shared/shadcn/components/button';
import { useLogin } from '@/pages/auth/login/model/use-login';
import { useAuthStore } from '@/configs/zustand/auth/auth.store';

// Bad - relative imports
import { Button } from '../../../shared/shadcn/components/button';
import { useLogin } from '../model/use-login';
```

### Type Imports

Use `import type` for type-only imports:

```typescript
import type { Theme } from '@/configs/zustand/theme/theme.store';
```

## Naming Conventions

| Type       | Convention                        | Example                          |
| ---------- | --------------------------------- | -------------------------------- |
| Files      | kebab-case                        | `use-login.ts`, `login.form.tsx` |
| Folders    | kebab-case                        | `google-login-button/`           |
| Components | PascalCase                        | `LoginForm`, `SidebarNav`        |
| Hooks      | camelCase with `use` prefix       | `useLogin`, `useAuthStore`       |
| Types      | PascalCase                        | `Theme`, `SignInFormData`        |
| Constants  | camelCase or SCREAMING_SNAKE_CASE | `navItems`, `API_BASE_URL`       |

## Code Conventions

### No Barrel Files

Do not create `index.ts` files that only re-export. Import directly from source:

```typescript
// Good
import { useThemeStore } from '@/configs/zustand/theme/theme.store';

// Bad
import { useThemeStore } from '@/configs/zustand/theme';
```

### Component Structure

Components follow this order:

1. Imports
2. Types (if component-specific)
3. Component function
4. Export

```typescript
import { Button } from '@/shared/shadcn/components/button';
import { useLogin } from '@/pages/auth/login/model/use-login';

export const LoginForm = () => {
  const { loginData, handleSubmit } = useLogin();

  return (
    <form onSubmit={handleSubmit}>
      {/* ... */}
    </form>
  );
};
```
